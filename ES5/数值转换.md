# 数值转化

今天重新翻阅了红宝书，重新学习了Number类型中数值转换这一章节，感觉有必要记录一下。
## 写在前面
在实现数据大屏时，前端对数据处理也许有这种需求：两数相除得到一个值，若该值小数点位数大于3，则取3位小数；若该值小数点位数小于3，则有多少位小数就保留多少位；若该值为整数，则保留整数。

出于用户体验上面需求确实合理，比如两数两除得到的是一个整数，给用户展示整数会更好些，因为硬生生给整数后面加3个0，会显得画蛇添足，适得其反。

针对上面的需求，可以充分利用数值转换中的parseFloat()方法一行代码解决上面的问题：
```
parseFloat((num1 / num2).toFixed(3))

// case1: 没有小数的情况，即整数
parseFloat((21000 / 1000).toFixed(3)) // 21

// case2: 有1位小数的情况
parseFloat((21200 / 1000).toFixed(3)) // 21.2

// case3: 有3位小数的情况
parseFloat((21005 / 1000).toFixed(3)) // 21.005
```

下面我们具体来看下数值转换相关的内容

## 数值转换
有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()。Number()可以用于任何数据类型，parseInt()和parseFloat()则专门用于把字符串转换成数字。这三个函数对于同样的输入会存在返回的结果不同，如下
|输入 | Number()的输出 | parseInt()的输出 | parseFloat()的输出 | 
|---|---|---|---|
| ""| 0 | NaN | NaN | 
| "Hello World!"| NaN | NaN | NaN |
| "000011"| 11 | 11 | 11 |
| "123color"| NaN | 123 | 123 |
| true| 1 | NaN | NaN |
| "0xA"| 10 | 10 | 0 |
| "22.22.22"|NaN  |22  | 22.22 |
| "+1"|1  |1  | 1 |

## Number()

 1. 若是Boolean指，true和false将返回1和0
 2. 若是数值值，则是简单的传入和返回
 3. 若是null值，则返回0
 4. 若是undefined，则返回NaN
 5. 若是字符串。若字符串中只包含数字，则会转换为十进制的数值；若字符串包含有效的浮点格式，则转换为对应的浮点数值；若字符串中包含有效的十六进制格式，转换为相同大小的十进制；若字符串为空，则转换为0；若字符串中包含除前面以外的字符，则转换为NaN
 6. 若是对象，则调用对象valueOf()方法，在按照前面规则进行转换返回值。若结果是NaN，则再调用对象toString()方法，再次依照签名的规则进行转换

## parseInt()
parseInt()在进行转换的时候，看其是否符合数值模式。会自动忽略前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或负号，则返回NaN。若第一个是字符，则会继续解析直到为非数字字符

 1. 0x开头且后跟数字字符，按照十六进制来解析，当做一个十六进制整数
 2. 0开头且后跟数字字符，则会将其当做一个八进制数来解析（ps：在八进制解析字面量的字符串时，ES3和ES5存证分歧。如parseInt("070")，ES3认为是56（按八进制解析），ES5认为是70（按十进制解析））
 3. 数字开头，自然是按照十进制来解析
 
 我们在使用的时候最好明确指定一个基数，可以避免一些错误的解析，如下：
 ```
 var num1 = parseInt("AF", 16);   // 175
 var num2 = parseInt("AF", 16);  // 175
 var num2 = parseInt("AF");    // NaN
 ```
指定基数会影响结果输出：
 ```
 var num1 = parseInt("10", 2);         // 2 （按二进制解析）
 var num2 = parseInt("10", 8);        // 8    (按八进制解析)
 var num3 = parseInt("10", 10);      // 10  (按十进制解析)
 var num4 = parseInt("10", 16);     // 16 （按十六进制解析）
 ```
## parseFloat()
parseFloat()和parseInt()类似，parseFloat()也是从第一个字符开始解析每个字符，一直解析到字符串末尾或遇到一个无效的浮点数字字符为止。即在一个字符串中，若有多个小数点，那么第一个小数点是有效的，第二个小数点就无效了，比如"22.23.24"将会被转换为22.23。

需要注意

 - parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。十六进制的字符串都会被解析为0。
 - 如果字符串包含的是一个可解析为整数的数（没有小数点或小数点后都是零），parseFloat()会返回整数，这就是我们文章开头提到的需求，通过parseFloat()实现。
 